import { HeroPattern } from '@/components/HeroPattern'
export const metadata = {
  title: 'Configure Ergosfare',
  description:
    'Learn more about how the system is structured and the main building blocks.',
}


export const sections = [
  { title: 'Shared packages', id: 'shared-packages'},
  { title: 'Core Module' , id: 'core-module' },
  { title: 'Command Module', id: 'command-module' },
  { title: 'Query Module', id: 'query-module' },
  { title: 'Event Module', id: 'event-module' },
  { title: 'Hands-On Examples', id: 'handls-on-examples' }
]


<HeroPattern />

## Shared Packages {{ id: 'shared-packages' }}


Shared packages provide the common foundation that other modules in Ergosfare build upon. They encapsulate cross-cutting concerns and reusable abstractions, ensuring consistency across commands, queries, and events.


### Ergosfare.Context

Provides the execution context infrastructure that flows through every part of the Ergosfare pipeline.

- Defines the `IExecutionContext` contract, which is passed into every handler and interceptor.
- Exposes methods and properties for setting and retrieving contextual data that can be shared across pipeline stages. For example, a pre-interceptor can attach a ticketId that the actual handler later consumes.
- Includes a CancellationToken property, allowing cooperative cancellation of long-running operations in handlers or interceptors.
- Provides the Abort() method, which throws an ExecutionAborted exception to immediately stop pipeline execution when necessary.
- hips with the AmbientExecutionContext static helper, which holds a reference to the current active execution context.
  - Supports creating scoped contexts via AmbientExecutionContext.CreateScope(...), allowing temporary contexts to be established for a block of code while automatically restoring the previous one when the scope ends.
      
      ```cs
        // Get the current execution context
      var current = AmbientExecutionContext.Current;

      // Create a new scoped execution context
      await using (var scope = AmbientExecutionContext.CreateScope(new DefaultExecutionContext()))
      {
          var scoped = AmbientExecutionContext.Current;

          // Set data in the new context
          scoped.Set("ticketId", Guid.NewGuid());

          // Retrieve the data later in the pipeline
          var ticketId = scoped.Get<Guid>("ticketId");

          Console.WriteLine($"Scoped ticket: {ticketId}");
      }

      // After the scope ends, the old context is restored
      var restored = AmbientExecutionContext.Current;
      Console.WriteLine(ReferenceEquals(current, restored)); // True
      ```


Together, this package makes execution context a first-class citizen in Ergosfare, enabling:
- Clean data propagation across handlers and interceptors.
- Scoped resource and request management.
- Early termination or cooperative cancellation of pipelines.


### Ergosfare.Contracts
Defines the core contracts and handler interfaces used across the entire framework.
- Contains only interfaces and base abstractions such as `ICommandHandler<TRequest>`, `IAsyncQueryHandler<TRequest, TResult>`, and `IEventHandler<TRequest>`.
- Acts as the common dependency for all modules (Commands, Queries, Events), ensuring that message and handler definitions stay consistent.
- Allows developers to define commands, queries, and events — and their handlers — without referencing the full module.
- Modules like Commands.Abstractions or Queries.Abstractions rely on these shared contracts instead of redefining their own handler types.
- The actual modules (Commands, Events, etc.) are only required at registration time, when wiring up handlers and module behavior.

## Core Module {{ id: 'core-module'}}

The Core Module is the foundation of Ergosfare. It brings together the shared packages (Ergosfare.Context, Ergosfare.Contracts) and provides the runtime infrastructure that powers the entire pipeline. Every other module builds on top of this core.

### Key responsibilities of core module
- Pipeline Execution → Orchestrates how commands, queries, and events flow through their respective pipelines. Each message passes through interceptors, middleware, and finally the appropriate handler.

- Handler Resolution → Uses dependency injection to locate and invoke the correct handler for a given message type.

- Interception Support → Provides hooks for pre- and post-processing (logging, validation, metrics, authorization, etc.) via interceptor interfaces.

- Execution Context Integration → Ensures that every handler and interceptor receives the active IExecutionContext, enabling shared state, scoped resources, cancellation, and pipeline aborts.
- Error & Exception Handling → Defines strategies for handling exceptions in a consistent, extensible way across the framework.


In short, the Core Module acts as the engine of Ergosfare — coordinating how messages are processed, how cross-cutting concerns are applied, and how execution context flows through the system. Without it, higher-level modules like Commands, Queries, or Events cannot function.
## Command Module {{ id: 'command-module' }}

The Command Module is responsible for handling intent-driven operations within Ergosfare. Commands represent actions that change the state of the system, such as creating an order, updating a customer profile, or processing a payment.


### Key responsibilities of the Command Module:
- Message Handling → Orchestrates command processing through the pipeline, ensuring that each command reaches the correct handler.
- Decoupled Architecture → Commands and their handlers are defined via interfaces in Ergosfare.Contracts, enabling developers to implement functionality without tightly coupling to the module itself.
- Module Registration → The Command Module is brought into the system during registration, at which point all command handlers are wired into the dependency injection container and the pipeline.


In short, the Command Module provides a structured, reliable mechanism for processing state-changing operations in an event-driven, decoupled way. It forms the foundation for building actionable business logic in Ergosfare while keeping handlers isolated, testable, and reusable.
## Query Module {{id: 'query-module' }}
The Query Module is responsible for handling read-only operations within Ergosfare. Queries represent questions about the system’s state, such as retrieving customer information, listing orders, or fetching inventory levels.
### Key responsibilities of the Query Module:
- Message Handling → Routes queries through the pipeline to the appropriate query handler, ensuring consistent and predictable data retrieval.
- Integration with Core Module → Uses the Core Module’s pipeline, execution context (IExecutionContext), and interceptors to handle cross-cutting concerns like caching, logging, or authorization.
- Decoupled Architecture → Query handlers implement interfaces defined in Ergosfare.Contracts (e.g., `IAsyncQueryHandler<TQuery, TResult>`), allowing developers to define queries without directly referencing the module.
- Module Registration → The Query Module is registered with the system, wiring up all query handlers for runtime resolution.
- Extensibility → Supports custom interceptors, decorators, or query-specific middleware for additional behaviors without changing the core pipeline.

The Query Module ensures that data retrieval is separated from state-changing operations, maintaining a clean, testable, and maintainable architecture. It enables developers to build robust, scalable, and predictable read paths in their applications.


___
## Event Module {{id: 'event-module' }}
The Event Module handles domain events and notifications within Ergosfare. Events represent things that have already happened in the system, such as OrderPlaced, CustomerUpdated, or PaymentProcessed.
event module description here


### Key responsibilities of the Event Module:
- Message Handling → Delivers events to all registered event handlers, allowing multiple components to react to the same event independently.
- Integration with Core Module → Utilizes the Core Module’s pipeline, execution context (IExecutionContext), and interceptors to support cross-cutting concerns like logging, auditing, or metrics.
- Decoupled Architecture → Event handlers implement interfaces defined in Ergosfare.Contracts (e.g., `IEventHandler<TEvent>`), so developers can respond to events without depending on the event publisher directly.
- Module Registration → Event handlers are registered with the system at runtime, enabling automatic resolution and invocation whenever events are published.
- Extensibility → Supports custom interceptors, decorators, or event-specific middleware to extend event processing without modifying the core pipeline.

The Event Module promotes a reactive, decoupled architecture, enabling multiple parts of the system to respond to changes independently. It ensures that side-effects, notifications, and asynchronous workflows remain organized, maintainable, and testable.



## Hands-On Examples {{id: 'handls-on-examples'}}

You’ve explored the core concepts of Ergosfare — from shared packages and execution context to the Command, Query, and Event modules. Now it’s time to put that knowledge into practice.
<div className="not-prose mt-6 mb-16 flex gap-3">
  <Button href="/built-with-ergosfare" arrow="right">
    </Button>
    <>Building with Ergosfare</>
</div>