(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[433],{5265:(e,t,r)=>{"use strict";r.r(t),r.d(t,{search:()=>a});let n=new(r(5947)).Ay.Document({tokenize:"full",document:{id:"url",index:"content",store:["title","pageTitle"]},context:{resolution:9,depth:2,bidirectional:!0}});for(let{url:e,sections:t}of[{url:"/",sections:[["Why Ergosfare? ","why-ergosfare",["In the fast-paced world of software development, building scalable and maintainable applications can be a complex challenge. Ergosfare was created to simplify this process, offering a framework that balances structure with flexibility. At its heart, Ergosfare empowers developers to focus on what truly matters: delivering robust business logic, without getting lost in repetitive boilerplate code.","Ergosfare embraces an event-driven architecture, seamlessly integrating commands, queries, and events into a coherent workflow. Its modular design allows teams to extend functionality easily, ensuring that applications remain adaptable as requirements evolve. Features like dependency injection, event interception, and streamlined messaging are built-in, providing a solid foundation for both small projects and enterprise-scale systems.","More than just a framework, Ergosfare represents a philosophy: simplifying complexity while keeping developers in control. It’s designed to accelerate development, improve code quality, and empower teams to build software that’s resilient, maintainable, and future-ready. "]],["Getting started ","getting-started",["Getting started with Ergosfare is simple. Set up a new project, explore the core modules, and begin building your application using the framework’s event-driven architecture. For a step-by-step guide, see the Quickstart\nsection to get your first integration up and running in minutes.","Quickstart"]]]},{url:"/groups",sections:[["Groups",null,["Groups are where communities live in Protocol — they are a collection of contacts you're talking to all at once. On this page, we'll dive into the different group endpoints you can use to manage groups programmatically. We'll look at how to query, create, update, and delete groups. "]],["The group model","the-group-model",["The group model contains all the information about your groups, including what contacts are in the group and the group's name, description, and avatar.","Properties","Unique identifier for the group.","The name for the group.","The description for the group.","The avatar image URL for the group.","Unique identifier for the conversation that belongs to the group.","An array of contact objects that are members of the group.","Timestamp of when the group was created.","Timestamp of when the group was archived."]],["List all groups ","list-all-groups",["This endpoint allows you to retrieve a paginated list of all your groups. By default, a maximum of ten groups are shown per page.","Optional attributes","Limit the number of groups returned.","Only show groups that are archived when set to true."]],["Create a group ","create-a-group",["This endpoint allows you to create a new group conversation between you and a group of your Protocol contacts.","Required attributes","The name for the group.","Optional attributes","The description for the group.","The avatar image URL for the group.","An array of contact objects that are members of the group."]],["Retrieve a group ","retrieve-a-group",["This endpoint allows you to retrieve a group by providing the group id. Refer to the list at the top of this page to see which properties are included with group objects."]],["Update a group ","update-a-group",["This endpoint allows you to perform an update on a group. Examples of updates are changing the name, description, and avatar or adding and removing contacts from the group.","Optional attributes","The new name for the group.","The new description for the group.","The new avatar image URL for the group.","An array of contact objects that are members of the group.","Timestamp of when the group was archived."]],["Delete a group ","delete-a-group",["This endpoint allows you to delete groups. Note: This will permanently delete the group, including the messages — archive it instead if you want to be able to restore it later."]]]},{url:"/quickstart",sections:[["Quickstart",null,["This guide will help you set up your first Ergosfare project and start using the framework’s core features. You’ll learn how to create a new project, configure essential modules, and handle your first commands, queries, and events. By the end, you’ll have a working foundation to build on and know where to go next for advanced features. ","Before you can start using Ergosfare, make sure your environment meets the following requirements:","At least C# 13",".NET 9"]],["Create a .NET 9+ project","create-a-net-9-project",["Before you can start building your web application, you need to create an ASP.NET Core project and integrate Ergosfare. Ergosfare provides a modular framework for handling commands, queries, and events, along with a C# SDK to simplify development."]],["Add Ergosfare to your project","add-ergosfare-to-your-project",["To use Ergosfare in your application, you need to add the SDK to your project. This allows you to access its core features, including commands, queries, events, and built-in modules for dependency injection and messaging. You can install it via the .NET CLI or the NuGet Package Manager."]],["Configure Ergosfare in Your Application","configure-ergosfare-in-your-application",["Once the Ergosfare SDK is installed, you need to register it with the ASP.NET Core dependency injection container. This allows your application to access commands, queries, events, and other framework features throughout your project.","The AddErgosfare extension automatically registers the core services and modules needed for commands, events, and queries.","You can further customize the options to enable event interception, logging, or other extensions.","Once registered, you can inject the necessary Ergosfare services into your controllers or other services using constructor injection.","Define a Command","A command represents an action or request in your system. Here, CreateOrderCommand contains the necessary data to create a new order.","Commands are simple DTOs that carry data.","They do not contain business logic—handlers do.","Implement a Command Handler","The handler contains the business logic for processing the command.","Implements  ICommandHandler<TCommand> to handle a specific command.","Can perform database operations, validation, logging, or any other business logic.","Register the Handler with Ergosfare","Add the command handler to the dependency injection container so Ergosfare can resolve it when commands are dispatched.","Both Register<TCommand>() and RegisterFromAssembly(...) not only tell Ergosfare about the command types, but also ensure their handlers are registered in the ASP.NET Core service container. This means you can immediately inject and use them without additional configuration","Sending commands","ICommandMediator handles dispatching commands to the appropriate handler.","API endpoints remain thin and focused on request/response logic.","Business logic stays in the command handler, keeping your code modular and testable."]],["Explore the Core Concepts?","explore-the-core-concepts",["Great, you're now set up with an API client and have made your first request to the API. Here are a few links that might be handy as you venture further into the Protocol API:","Configuring Ergosfare","Check out the Conversations endpoint","Learn about the different error messages in Protocol"]]]},{url:"/building-with-ergosfare/commands-and-command-handlers",sections:[["What is a Command ","what-is-a-command",["In Ergosfare, commands represent intent-driven operations — actions that change the state of your system. Commands are the starting point for workflows that perform tasks, trigger side effects, or produce results.","Key Characteristics of Commands ","Commands are always intended to change the state of the system.","Represents Intent or Action, A command models  a request to perform a specific operation.","It expresses what should happen, not how.","Commands carry all the information required to perform the action.","They act as a self-contained message or instruction.","Commands are typically immutable once created, ensuring the action’s intent cannot change mid-flight.  (Ergosfare still have ability to modify commands)","Single Responsibility: Each command represents one discrete operation, Avoid bundling multiple unrelated actions into a single command.","Key Concepts ","Commands are messages: They encapsulate all information needed to perform an action.","Two types of commands:","ICommand; Commands without return values (fire-and-forget).","ICommand<TResult>; Commands with return values (request-response).","Commands are decoupled from handlers: Handlers implement ICommandHandler<TCommand> or ICommandHandler<TCommand, TResult> depending on whether the command produces a result.","Polymorphism and generics: Commands can be derived from base commands or use generic parameters, enabling flexible and reusable workflows."]],["How to Create a Command ","how-to-create-a-command",["Command without a result ","A basic command that performs an action but does not return any value.","Implements ICommand.","Encapsulates all information needed to perform the action.","Handled by a handler implementing ICommandHandler<TCommand>.","Example: CreateMassCommand represents creating a mass without returning an ID or result.","Command with a result ","A command that produces a result after execution.","Implements ICommand<TResult>.","The type parameter TResult specifies the result type returned by the handler.","Handled by a handler implementing ICommandHandler<TCommand, TResult>.","Example: CreateMassCommand : ICommand<Guid> returns a GUID of the created mass.","Derived Command ","A command that inherits from a base command, adding additional properties or behavior.","Supports polymorphism: handlers for the base command can handle the derived command unless a specific handler exists.","Enables code reuse and specialization without duplicating logic.","Example: CreatePlanetCommand extends CreateMassCommand by adding an OrbitRadius property.","Generic Command ","A parameterized command that can handle multiple related types with a single handler.","Uses generics to define a type-safe, reusable command structure.","Integrates with handlers implementing ICommandHandler<GravityCommand<TGravity>>.","Supports generic polymorphism, so new gravity types automatically work with the same handler.","Example: GravityCommand<TGravity> can represent MassGravityCommand or ArtificialGravityCommand without creating separate handlers for each."]],["What is a Command Handler ","what-is-a-command-handler",["A command handler is a dedicated component responsible for executing the logic associated with a command.\r\nWhile a command represents the intent to perform an action, the command handler defines how that action is carried out.\r\nThis separation ensures a clean distinction between the data describing the operation and the logic that executes it.","Key Characteristics of Command Handlers ","Processes commands: Command handlers receive commands and perform the corresponding state-changing operations.","Type-specific: Handlers are strongly typed to a specific command (or base/derived command), ensuring type-safe execution.","Supports polymorphism: Handlers can process derived commands when designed for a base type, enabling code reuse and flexible dispatching.","Decoupled from command creation: Handlers focus purely on execution, leaving commands as immutable carriers of intent.","Optional result handling: For commands that produce a result, handlers implement interfaces that return the corresponding type.","Example Concept","A CreateFileCommandHandler processes a CreateFileCommand by implementing the necessary logic to create a file.","If a derived command like CreateImageCommand exists, a specialized handler can override the base logic or provide additional behavior.","In essence: A command handler is the executor of commands, translating the intent expressed in a command into actual system changes, while maintaining clean separation and type safety."]],["How to Create a Command Handler","how-to-create-a-command-handler",["Command handlers are responsible for executing the logic associated with a command. When creating a handler, you implement the appropriate interface based on whether your command produces a result or not.","Key Points","Handlers are type-specific: Each handler is strongly typed to the command it handles.","Separation of concerns: The command carries data; the handler contains execution logic.","Supports polymorphism: Handlers can process derived commands if the interface is contravariant.","Optional results: Use a result-typed interface for commands that return a value.","Command Handler that does not return a result","This kind of handler must implement the ICommandHandler<TCommand> interface.","Behavior:","Processes commands in a fire-and-forget style.","Can handle CreateStarCommand and any derived commands (e.g., CreateRedGiantCommand) due to contravariance.","Command Handler that returns a result","If the handler returns a result, it must implement the ICommandHandler<TCommand, TResult> interface.","Behavior:","Processes commands and returns a result (e.g., the ID of the created star).","Can handle CreateStarWithIdCommand and any derived commands due to contravariance. even if CreateStarWithIdCommand casted its base type.","Polymorphic Command Handlers","Polymorphic command handlers are handlers that can process multiple related commands through inheritance or generics, enabling flexible, reusable, and type-safe workflows.","Key Concepts","Generic and base-type support: A single handler can handle any command derived from a base type or parameterized generic commands.","Contravariant input: Handlers for a base command type can process derived commands automatically.","Covariant result (if applicable): Handlers returning a result can provide derived result types that satisfy expectations for base result types.","Reduced duplication: One polymorphic handler replaces multiple specialized handlers, while still supporting specialized behavior when needed.","Type safety: Even with polymorphism, the compiler ensures that handlers only process compatible command types.","Example Concept","A GravityCommandHandler<TGravity> can handle GravityCommand<MassGravity> and GravityCommand<ArtificialGravity> using the same code.","Adding a new type like BlackHoleGravity requires no new handler — the existing generic handler handles it automatically.","so we can create a single generic handler to handle all types of GravityCommand<TGravity>:","Learn how Ergosfare leverages contravariance, covariance, and polymorphism to let your handlers work seamlessly with base and derived commands. For more information look at ","polymorphism in Ergosfare"]],["Registering Command Handlers ","registering-command-handlers",["Once you’ve created a command handler, you need to tell Ergosfare about it.\r\nErgosfare integrates with Microsoft.Extensions.DependencyInjection, so you simply register your handlers when configuring your services.","To register command handlers to Ergosfare, whithin Stella.Ergosfare.Core.*  you need to add  Stella.Ergosfare.Commands, Stella.Ergosfare.Commands.Abstractions and Stella.Ergosfare.Commands.Extensions.MicrosoftDependencyInjection packages to your project.","Then, in your Program.cs or Startup.cs, you can register the command module and your handlers like this:"]],["Dispatching a Command ","dispatching-a-command",["Once your handlers are registered, you can dispatch commands using the ICommandMediator.\r\nThe ICommandMediator ensures the correct handler is resolved and invoked.","ICommandMediator is automatically registered in the DI container when you add CommandModule, so you can inject it into your services or controllers."]]]},{url:"/building-with-ergosfare/events-and-event-handlers",sections:[["What is an Event ","what-is-an-event",["In Ergosfare, events represent something that has happened in your system.Unlike commands (which express intent to change state), events are facts: they describe state changes that already occurred.","Events are commonly used to notify other parts of the system or external services that something has happened.","Key Characteristics of Events ","Events represent something that already happened, not an intent.","They are immutable once published — you cannot change history.","Events can have multiple subscribers (unlike commands which have exactly one handler).","They decouple producers from consumers: the producer doesn’t know (or care) who listens.","Events can be explicitly defined by implementing IEvent.","Alternatively, you can use plain POCO/POJO events — Ergosfare allows domain events that don’t depend on Ergosfare abstractions at all."]],["How to Create an Event ","how-to-create-an-event",["Creating an event is straightforward. You have two options:","Defining an event with IEvent","Using a plain POCO/POJO as an event","\uD83D\uDC49 Both approaches work in Ergosfare.","Use IEvent for explicit framework integration.","Use POCO/POJO events when modeling pure domain events without referencing Ergosfare."]],["What is an Event Handler ","what-is-an-event-handler",["An event handler is a component that reacts when an event is published.\r\nWhile the event represents a fact, the handler contains the logic of how the system responds to that fact.","Key Characteristics of Event Handlers ","Listens for events and executes side effects in response.","Multiple handlers can subscribe to the same event.","Strongly typed to a specific event type, ensuring type safety.","Decoupled from event creation — handlers don’t influence how or when events are raised.","Can react to either IEvent-based or plain POCO/POJO events."]],["How to Create an Event Handler ","how-to-create-an-event-handler",["Event handlers implement the IEventHandler<TEvent> interface.","Example: handling an IEvent-based event","Example: handling a plain POCO/POJO event"]],["Registering Event Handlers ","registering-event-handlers",["Once you’ve created event handlers, you must register them with Ergosfare.","Add the following packages to your project:","Stella.Ergosfare.Core.*","Stella.Ergosfare.Events","Stella.Ergosfare.Events.Abstractions","Stella.Ergosfare.Events.Extensions.MicrosoftDependencyInjection","Then configure in Program.cs:"]],["Dispatching an Event ","dispatching-an-event",["Once registered, you can publish events using the IEventMediator.Unlike commands, all matching event handlers will be invoked.","IPublisher is also available as a shorthand alias of IEventMediator.  You can use either interface interchangeably depending on your style preference.","Both IEventMediator and IPublisher are automatically registered in DI when you add the EventModule."]]]},{url:"/building-with-ergosfare/queries-and-query-handlers",sections:[["What is a Query ","what-is-a-query",["In Ergosfare, queries represent read-only operations — requests for information that do not modify system state.They are used to retrieve, project, or transform data without causing side effects.","Key Characteristics of Queries ","Queries are read-only: They never change the state of the system.","Represent a question: A query models a request for information.","Always return data: Queries are always coupled with a result type.","Self-contained: Carry all necessary parameters to fetch the requested data.","Immutable once created: Ensures the request remains consistent throughout execution.","Decoupled from handlers: The query defines what to fetch, the handler defines how to fetch it.","Key Concepts ","Queries are messages: They encapsulate all input data needed to retrieve information.","Only one type of query interface: IQuery<TResult>.","Queries are decoupled from their execution: Handlers implement IQueryHandler<TQuery, TResult>.","Polymorphism and generics: Queries can be derived or generic, supporting flexible read models."]],["How to Create a Query ","how-to-create-a-query",["Basic Query ","The most basic query returns data of a specified type.","Implements IQuery<TResult>.","Encapsulates criteria for retrieval.","Handled by a IQueryHandler<TQuery, TResult>.","Example: Retrieve the mass of a star by ID.","Derived Query ","A query that specializes a base query to add new filtering or criteria.","Supports polymorphism: a handler for the base query can also process derived queries.","Promotes reuse and specialization.","Example: GetStarByNameQuery extends a more generic GetStarQuery.","Generic Query ","A parameterized query that can retrieve multiple related types with a single handler.","Defines a reusable query pattern.","Handlers can process any type parameter satisfying the constraints.","Example: Query different gravity models."]],["What is a Query Handler ","what-is-a-query-handler",["A query handler is responsible for retrieving and returning data requested by a query.\r\nWhile a query describes what information is needed, the handler defines how that information is fetched.","Key Characteristics of Query Handlers ","Processes queries: They execute retrieval logic based on query data.","Always return data: Query handlers are required to return a result.","Type-safe: Strongly typed to a specific query and result type.","Polymorphic: Handlers can process derived or generic queries when applicable.","Separation of concerns: Queries describe what to retrieve, handlers implement how to retrieve.","Example Concept","A GetStarMassQueryHandler processes GetStarMassQuery and returns a double.","If GetStarByNameQuery extends GetStarQuery, the same handler could process both via polymorphism."]],["How to Create a Query Handler","how-to-create-a-query-handler",["Query handlers are created by implementing the IQueryHandler<TQuery, TResult> interface.","Query Handler Example","Polymorphic Query Handlers","Polymorphic query handlers allow a single handler to process related queries using inheritance or generics.","Example: Generic handler for any gravity type","Learn how Ergosfare leverages contravariance, covariance, and polymorphism to let your query handlers work seamlessly with base and derived queries. ","For more information see Polymorphism in Ergosfare"]],["Registering Query Handlers ","registering-query-handlers",["Once you’ve created a query handler, you need to tell Ergosfare about it.\r\nJust like commands, you register queries through Microsoft.Extensions.DependencyInjection.","To register query handlers, add the following packages to your project:","Stella.Ergosfare.Core.*","Stella.Ergosfare.Queries","Stella.Ergosfare.Queries.Abstractions","Stella.Ergosfare.Queries.Extensions.MicrosoftDependencyInjection","Then, in your Program.cs or Startup.cs, register the query module and your handlers:"]],["Dispatching a Query","dispatching-a-query",["Once registered, queries can be dispatched using the IQueryMediator.\r\nThe IQueryMediator ensures the correct query handler is invoked and returns the expected result.\r\nIQueryMediator is automatically available in DI when you add the QueryModule."]]]},{url:"/core-concepts/configuration",sections:[["Basic configurations ","basic-configurations",["The Basic Configurations section demonstrates how to set up Ergosfare modules and register your handlers using dependency injection.","In this example, the AddErgosfare extension method is used to configure the framework and enable the Command, Query, and Event modules. Each module is configured via a builder of type IModuleBuilder, which provides methods for registering handlers from assemblies, configuring pipelines, or adding custom behavior.","Key points: ","options.AddCommandModule(...) → Registers the Command module and its handlers.","options.AddQueryModule(...) → Registers the Query module and its handlers.","options.AddEventModule(...) → Registers the Event module and its handlers.","builder.RegisterFromAssembly(Assembly.GetExecutingAssembly()) → Automatically discovers and registers all handlers (commands, queries, or events) from the specified assembly."]],["IModule Builder Methods ","i-module-builder-methods",["The IModuleBuilder interface provides several methods to register handlers in a module, giving you flexible options for wiring up commands, queries, and events.","Register<T>()","Registers a single handler by its generic type.","T must implement the appropriate handler interface such as ICommandHandler<T>, IAsyncQueryHandler<T,R>, IEventHandler<T>, etc.","Useful for registering individual handlers explicitly.","Register(Type type)","Registers a handler by providing a Type instance.","Allows dynamic registration when the handler type is determined at runtime.","Works with any type that implements a valid handler interface.","RegisterFromAssembly(Assembly assembly)","Automatically discovers and registers all handlers from a given assembly.","Scans the specified assembly for all classes implementing handler interfaces.","Saves time and reduces boilerplate by batch-registering multiple handlers at once.","By understanding and using these methods, you can control how and where handlers are registered, whether you prefer explicit single registrations or assembly-wide automatic discovery."]]]},{url:"/core-concepts/interceptors",sections:[]},{url:"/core-concepts/modules-and-extensions",sections:[["Shared Packages ","shared-packages",["Shared packages provide the common foundation that other modules in Ergosfare build upon. They encapsulate cross-cutting concerns and reusable abstractions, ensuring consistency across commands, queries, and events.","Ergosfare.Context","Provides the execution context infrastructure that flows through every part of the Ergosfare pipeline.","Defines the IExecutionContext contract, which is passed into every handler and interceptor.","Exposes methods and properties for setting and retrieving contextual data that can be shared across pipeline stages. For example, a pre-interceptor can attach a ticketId that the actual handler later consumes.","Includes a CancellationToken property, allowing cooperative cancellation of long-running operations in handlers or interceptors.","Provides the Abort() method, which throws an ExecutionAborted exception to immediately stop pipeline execution when necessary.","hips with the AmbientExecutionContext static helper, which holds a reference to the current active execution context.","Supports creating scoped contexts via AmbientExecutionContext.CreateScope(...), allowing temporary contexts to be established for a block of code while automatically restoring the previous one when the scope ends.","Together, this package makes execution context a first-class citizen in Ergosfare, enabling:","Clean data propagation across handlers and interceptors.","Scoped resource and request management.","Early termination or cooperative cancellation of pipelines.","Ergosfare.Contracts","Defines the core contracts and handler interfaces used across the entire framework.","Contains only interfaces and base abstractions such as ICommandHandler<TRequest>, IAsyncQueryHandler<TRequest, TResult>, and IEventHandler<TRequest>.","Acts as the common dependency for all modules (Commands, Queries, Events), ensuring that message and handler definitions stay consistent.","Allows developers to define commands, queries, and events — and their handlers — without referencing the full module.","Modules like Commands.Abstractions or Queries.Abstractions rely on these shared contracts instead of redefining their own handler types.","The actual modules (Commands, Events, etc.) are only required at registration time, when wiring up handlers and module behavior."]],["Core Module ","core-module",["The Core Module is the foundation of Ergosfare. It brings together the shared packages (Ergosfare.Context, Ergosfare.Contracts) and provides the runtime infrastructure that powers the entire pipeline. Every other module builds on top of this core.","Key responsibilities of core module","Pipeline Execution → Orchestrates how commands, queries, and events flow through their respective pipelines. Each message passes through interceptors, middleware, and finally the appropriate handler.","Handler Resolution → Uses dependency injection to locate and invoke the correct handler for a given message type.","Interception Support → Provides hooks for pre- and post-processing (logging, validation, metrics, authorization, etc.) via interceptor interfaces.","Execution Context Integration → Ensures that every handler and interceptor receives the active IExecutionContext, enabling shared state, scoped resources, cancellation, and pipeline aborts.","Error & Exception Handling → Defines strategies for handling exceptions in a consistent, extensible way across the framework.","In short, the Core Module acts as the engine of Ergosfare — coordinating how messages are processed, how cross-cutting concerns are applied, and how execution context flows through the system. Without it, higher-level modules like Commands, Queries, or Events cannot function."]],["Command Module ","command-module",["The Command Module is responsible for handling intent-driven operations within Ergosfare. Commands represent actions that change the state of the system, such as creating an order, updating a customer profile, or processing a payment.","Key responsibilities of the Command Module:","Message Handling → Orchestrates command processing through the pipeline, ensuring that each command reaches the correct handler.","Decoupled Architecture → Commands and their handlers are defined via interfaces in Ergosfare.Contracts, enabling developers to implement functionality without tightly coupling to the module itself.","Module Registration → The Command Module is brought into the system during registration, at which point all command handlers are wired into the dependency injection container and the pipeline.","In short, the Command Module provides a structured, reliable mechanism for processing state-changing operations in an event-driven, decoupled way. It forms the foundation for building actionable business logic in Ergosfare while keeping handlers isolated, testable, and reusable."]],["Query Module ","query-module",["The Query Module is responsible for handling read-only operations within Ergosfare. Queries represent questions about the system’s state, such as retrieving customer information, listing orders, or fetching inventory levels.","Key responsibilities of the Query Module:","Message Handling → Routes queries through the pipeline to the appropriate query handler, ensuring consistent and predictable data retrieval.","Integration with Core Module → Uses the Core Module’s pipeline, execution context (IExecutionContext), and interceptors to handle cross-cutting concerns like caching, logging, or authorization.","Decoupled Architecture → Query handlers implement interfaces defined in Ergosfare.Contracts (e.g., IAsyncQueryHandler<TQuery, TResult>), allowing developers to define queries without directly referencing the module.","Module Registration → The Query Module is registered with the system, wiring up all query handlers for runtime resolution.","Extensibility → Supports custom interceptors, decorators, or query-specific middleware for additional behaviors without changing the core pipeline.","The Query Module ensures that data retrieval is separated from state-changing operations, maintaining a clean, testable, and maintainable architecture. It enables developers to build robust, scalable, and predictable read paths in their applications."]],["Event Module ","event-module",["The Event Module handles domain events and notifications within Ergosfare. Events represent things that have already happened in the system, such as OrderPlaced, CustomerUpdated, or PaymentProcessed.\r\nevent module description here","Key responsibilities of the Event Module:","Message Handling → Delivers events to all registered event handlers, allowing multiple components to react to the same event independently.","Integration with Core Module → Utilizes the Core Module’s pipeline, execution context (IExecutionContext), and interceptors to support cross-cutting concerns like logging, auditing, or metrics.","Decoupled Architecture → Event handlers implement interfaces defined in Ergosfare.Contracts (e.g., IEventHandler<TEvent>), so developers can respond to events without depending on the event publisher directly.","Module Registration → Event handlers are registered with the system at runtime, enabling automatic resolution and invocation whenever events are published.","Extensibility → Supports custom interceptors, decorators, or event-specific middleware to extend event processing without modifying the core pipeline.","The Event Module promotes a reactive, decoupled architecture, enabling multiple parts of the system to respond to changes independently. It ensures that side-effects, notifications, and asynchronous workflows remain organized, maintainable, and testable."]],["Hands-On Examples ","hands-on-examples",["You’ve explored the core concepts of Ergosfare — from shared packages and execution context to the Command, Query, and Event modules. Now it’s time to put that knowledge into practice.","Building with Ergosfare"]]]},{url:"/core-concepts/polymorphism",sections:[["Polymorphism in Ergosfare ","polymorphism-in-ergosfare",["All Ergosfare handlers support polymorphism through contravariance on input and covariance on output. This allows handlers to process messages and return results across an inheritance hierarchy, reducing duplication and increasing flexibility.","Polymorphism covariance contravariance example ","behavior","Sending a SunCommand resolves to SunCommandHandler, even if cast as StarCommand.","Sending a SiriusCommand resolves to SiriusCommandHandler, following the same rule.","If a derived command has no specific handler, the base handler (StarCommandHandler) is invoked.","Benefits","Supports polymorphic dispatch for hierarchical commands.","Base handlers can handle general cases while derived handlers provide specialized behavior.","Clean, type-safe structure for commands and handlers in Ergosfare."]],["Generic type support ","generic-type-support",["Ergosfare supports generic types as part of polymorphism, enabling reusable, type-safe handlers for families of related messages","Generic command example","Behavior","A single generic handler (GravityCommandHandler<TGravity>) handles all gravity commands, whether MassGravityCommand or ArtificialGravityCommand.","Supports polymorphic dispatch if new gravity types are added later.\r\n` Reduces boilerplate and keeps your command pipeline clean and type-safe.","Benefits","Reusability: One handler for multiple gravity types.","Extensibility: Add new gravity types without creating new handlers.","Consistency: Integrates seamlessly with Ergosfare’s pipeline and execution context."]]]},{url:"/interceptors/exception-interceptors",sections:[["Exception Interceptors in Ergosfare ","exception-interceptors-in-ergosfare",["Exception interceptors are invoked when a command, query, or event handler throws an unhandled exception.They act as safety nets that let you log, transform, or react to errors before they escape the pipeline.","Think of them as shock absorbers in your system: they prevent unhandled exceptions from propagating unchecked and allow you to apply uniform error handling strategies such as logging, wrapping exceptions, retry scheduling, or user-friendly messaging."]],["Core Concepts ","core-concepts",["At the foundation of exception handling, Ergosfare provides a core interface:","TMessage is the message type (Command, Query, or Event).","exception is the unhandled exception thrown by the handler or any interceptor.","IExecutionContext provides contextual information like tenant, user identity, correlation IDs.","Core exception interceptors are only the foundation. To integrate properly into modules, you will usually use module-specific exception interceptor interfaces described below."]],["Module-Specific Exception Interceptor Interfaces ","module-specific-exception-interceptor-interfaces",["Each module provides its own dedicated exception interceptor interfaces that extend the core:","| Module  | Non-Generic Interface          | Generic Interface                        |\r\n| ------- | ------------------------------ | ---------------------------------------- |\r\n| Command | ICommandExceptionInterceptor | ICommandExceptionInterceptor<TCommand> |\r\n| Query   | IQueryExceptionInterceptor   | IQueryExceptionInterceptor<TQuery>     |\r\n| Event   | IEventExceptionInterceptor   | IEventExceptionInterceptor<TEvent>     |","Key Notes","Non-generic interceptors run for all messages within a module (e.g., all commands).","Generic interceptors target specific types (e.g., one command or query).","Using module-specific interfaces ensures automatic discovery and registration within the module."]],["Examples ","examples",["Module-Specific Exception Interceptor (Command)","Only applies to the Command module.","Runs when a command handler or interceptor throws an exception.","Non-Generic Exception Interceptor (All Commands)","Handles all commands uniformly.","Useful for global concerns like telemetry, error monitoring, or standardized wrapping."]],["Registering Exception Interceptors ","registering-exception-interceptors",["Exception interceptors are registered the same way as handlers and any other interceptors, using the Register<T>() method.","Any type implementing ICommandExceptionInterceptor<T>, IQueryExceptionInterceptor<T>, or IEventExceptionInterceptor<T> is automatically wired into its module’s pipeline.","No extra registration steps are required beyond Register<T>() or RegisterFromAssembly().","With exception interceptors, you gain a centralized and extensible mechanism to handle failures consistently across your Ergosfare-powered system."]]]},{url:"/interceptors/post-interceptors",sections:[["Post-Interceptors in Ergosfare ","post-interceptors-in-ergosfare",["Post-interceptors allow you to observe, modify, or react after a command, query, or event has been handled.They are ideal for concerns such as logging results, auditing, publishing domain events, caching, or transforming responses.Think of them as the “afterburners” of your message pipeline—kicking in right after your handlers finish execution."]],["Core Concepts ","core-concepts",["Ergosfare defines a core interface for post-interceptors, which is the foundation for all module-specific variants:","TMessage represents the type of the message (Command, Query, or Event).","IExecutionContext provides runtime context such as user identity, tenant, or correlation IDs.","Core interfaces cannot be directly registered in higher-level modules. They serve as foundations for module-specific post-interceptors."]],["Module-Specific Post-Interceptor Interfaces ","module-specific-post-interceptor-interfaces",["Each module defines dedicated post-interceptor interfaces:","| Module  | Non-Generic Interface     | Generic Interfaces                                                                 |\r\n| ------- | ------------------------- | ---------------------------------------------------------------------------------- |\r\n| Command | ICommandPostInterceptor | ICommandPostInterceptor<TCommand> , ICommandPostInterceptor<TCommand, TResult> |\r\n| Query   | IQueryPostInterceptor   | IQueryPostInterceptor<TQuery> , IQueryPostInterceptor<TQuery, TResult>         |\r\n| Event   | IEventPostInterceptor   | IEventPostInterceptor<TEvent>                                                    |","Key Notes","Non-generic interfaces run for all messages in a module (e.g., all commands).","Generic single-parameter interfaces apply to a specific type of message.","Generic dual-parameter interfaces (TMessage, TResult) allow interceptors to observe and modify the result of handlers (available for Commands & Queries only).","Module-specific interfaces are automatically discoverable by the registration system."]],["Examples ","examples",["Command Post-Interceptor (Generic)","Runs after any command of type TCommand completes.","Command Post-Interceptor with Result","Captures both the command and the handler’s result.","Useful for auditing, result transformations, or caching.","Non-Generic Command Post-Interceptor","Runs for every command regardless of type.","Useful for global logging, telemetry, or auditing.","Query Post-Interceptor with Result","Runs after a query is handled.","Can modify or cache query results."]],["Registering Post-Interceptors ","registering-post-interceptors",["Post-interceptors are registered the same way as handlers or as any other type of interceptor:","No special method is required; they use the same Register<T>() mechanism.","If an interceptor implements ICommandPostInterceptor<T> or ICommandPostInterceptor<T, TResult>, it is automatically added to the command pipeline.","With Post-Interceptors, you can extend processing after handlers, making them a natural fit for auditing, telemetry, caching, notifications, or chaining domain side-effects."]]]},{url:"/interceptors/pre-interceptors",sections:[["Pre-Interceptors in Ergosfare ","pre-interceptors-in-ergosfare",["Pre-interceptors allow you to observe, modify, or halt the execution of commands, queries, and events before they reach their handlers. Think of them as gravitational fields or shields that influence the trajectory of messages in your system. They are ideal for cross-cutting concerns like logging, validation, authorization, or context enrichment."]],["Core Concepts ","core-concepts",["Ergosfare defines a core interface for pre-interceptors, which is the foundation for all modules:","TMessage represents the type of message (Command, Query, or Event).","IExecutionContext provides contextual information (tenant, user identity, correlation IDs,).","this is demostration only, you cant register core module interfaces on any higher level module without module marker interfaces","Core module interfaces supposed to be foundation of higher level module-specific interfaces. Most of the time you will use module-specific interfaces below."]],["Module-Specific Pre-Interceptor Interfaces ","module-specific-pre-interceptor-interfaces",["Each module has dedicated pre-interceptor interfaces:","| Module  | Non-Generic Interface    | Generic Interface                  |\r\n| ------- | ------------------------ | ---------------------------------- |\r\n| Command | ICommandPreInterceptor | ICommandPreInterceptor<TCommand> |\r\n| Query   | IQueryPreInterceptor   | IQueryPreInterceptor<TQuery>     |\r\n| Event   | IEventPreInterceptor   | IEventPreInterceptor<TEvent>     |","Key Notes:","Non-generic interfaces are useful for interceptors that should run for all messages in a module.","Generic interfaces allow type-specific interception, e.g., only for a certain command or event.","Module-specific interfaces are used for automatic registration within a module."]],["Examples ","examples",["Module-Specific Pre-Interceptor (Command)","Only applies to the Command module.","Handles any command type due to contravariance.","Non-Generic Pre-Interceptor (All Commands)","Runs for all commands, regardless of their type.","No generic type parameter is needed."]],["Registering Pre-Interceptors ","registering-pre-interceptors",["Interceptors are registered using the same Register<T>() method as handlers. No extra method is required.","Pre-interceptors that implement ICommandPreInterceptor<T> or ICommandPreInterceptor are applied to the command pipeline."]]]},{url:"/interceptors/what-is-an-interceptor",sections:[["Basically an Interceptor ","basically-an-interceptor",["In Ergosfare, interceptors are pipeline components that allow you to observe, modify, or control the execution of commands, queries, and events before or after they reach their respective handlers. They act like gravity fields or shields in a space system, shaping the trajectory of messages as they travel through the pipeline.","While handlers focus purely on business logic, interceptors handle cross-cutting concerns, enabling you to keep your core logic clean, maintainable, and reusable."]],["Key Characteristics of Interceptors ","key-characteristics-of-interceptors",["Pipeline Integration: Interceptors sit in the execution pipeline for commands, queries, or events and are invoked automatically during dispatch.","Cross-Cutting Concerns: They are ideal for logging, validation, authorization, context propagation, and error handling.","Message Observation & Modification: Interceptors can inspect or modify messages as they pass through the pipeline.","Execution Control: They can abort execution early or conditionally skip downstream processing using the execution context.","Type-Specific or Generic: Interceptors can target specific message types or apply generically across multiple types.","Decoupled from Business Logic: Handlers remain focused on business logic, while interceptors manage infrastructural or cross-cutting concerns."]],["Types of Interceptors ","types-of-interceptors",["Ergosfare provides flexible interception points, depending on the stage of execution:","Pre-Execution Interceptors","Run before a handler executes.","Ideal for validation, logging input data, propagating context values, or enforcing authorization.","Post-Execution Interceptors","Run after a handler completes successfully.","Can log results, transform output, or trigger additional side effects.","Exception Interceptors","Run when a handler or an any other interception throws an exception.","Useful for centralized error handling, retries, or transforming exceptions into domain-specific responses."]],["How Interceptors Work ","how-interceptors-work",["Interceptors are invoked automatically in the pipeline sequence during command, query, or event dispatch. They receive the execution context (IExecutionContext) and the message instance, giving them full control over the flow:","Access contextual data such as tenant IDs, user identity, or correlation IDs.","Modify message properties before the handler executes.","Abort execution early with ExecutionContext.Abort().","Observe results or exceptions after execution.","This ensures a consistent, reusable mechanism for cross-cutting concerns without polluting the domain logic in handlers."]],["Example: Pre-Execution Interceptor ","example-pre-execution-interceptor",["Behavior:","Logs the message type before the handler executes.","Does not modify the message but could if needed."]],["Example: Exception Interceptor ","example-exception-interceptor",["Behavior:","Catches exceptions thrown by the handler or downstream interceptors.","Centralizes error logging or transformation."]],["Usage Scenarios ","usage-scenarios",["Interceptors can be used for a wide range of cross-cutting behaviors:","Logging & Telemetry: Track message flow, execution duration, and metrics.","Validation & Authorization: Enforce rules before the message reaches the handler.","Context Propagation: Share tenant IDs, correlation IDs, or other scoped information.","Error Handling: Retry failed operations, log errors, or convert exceptions into domain events.","Dynamic Behavior: Modify messages, cancel execution, or trigger additional side effects conditionally."]]]}])for(let[r,a,o]of t)n.add({url:e+(a?"#"+a:""),title:r,content:[r,...o].join("\n"),pageTitle:a?t[0][0]:void 0});function a(e,t={}){let r=n.search(e,{...t,enrich:!0});return 0===r.length?[]:r[0].result.map(e=>({url:e.id,title:e.doc.title,pageTitle:e.doc.pageTitle}))}},7809:()=>{}}]);